from dataclasses import dataclassfrom enum import Enumfrom typing import Optional, Tuple, Listfrom mathutils import Vectorfrom yk_gmd_blender.structurelib.base import StructureUnpacker, BasePrimitive, FixedSizeArrayUnpacker, ValueAdaptor, \    BaseUnpackerfrom yk_gmd_blender.structurelib.primitives import c_float32, c_float16, c_unorm8, c_uint8, RangeConverterPrimitivefrom yk_gmd_blender.yk_gmd.v2.structure.common.vector import Vec3Unpacker, Vec4Unpacker, Vec3Unpacker_of, \    Vec4Unpacker_ofclass VecStorage(Enum):    Vec4Fixed = 1    Vec2Full = 2    Vec3Full = 3    Vec4Full = 4    Vec2Half = 5    Vec3Half = 6    Vec4Half = 7class FixedConvertMethod(Enum):    To0_1 = 0    ToMinus1_1 = 1    ToByte = 2def list2_to_tuple2(list2: List):    return (list2[0], list2[1])def make_vector_unpacker(vec_type: VecStorage, byte_convert: Optional[FixedConvertMethod] = None) -> BaseUnpacker:    if vec_type == VecStorage.Vec2Full:        return ValueAdaptor(tuple, base_unpacker=FixedSizeArrayUnpacker(c_float32, 2), forwards=list2_to_tuple2, backwards=None)    elif vec_type == VecStorage.Vec3Full:        return Vec3Unpacker_of(c_float32)    elif vec_type == VecStorage.Vec4Full:        return Vec4Unpacker_of(c_float32)    elif vec_type == VecStorage.Vec2Half:        return ValueAdaptor(tuple, base_unpacker=FixedSizeArrayUnpacker(c_float16, 2), forwards=list2_to_tuple2, backwards=None)    elif vec_type == VecStorage.Vec3Half:        return Vec3Unpacker_of(c_float16)    elif vec_type == VecStorage.Vec4Half:        return Vec4Unpacker_of(c_float16)    elif vec_type == VecStorage.Vec4Fixed:        if not byte_convert:            print(f"Field had vec_type = Vec4Fixed but gave no byte_convert, assuming ToByte")            byte_convert = FixedConvertMethod.ToByte        if byte_convert == FixedConvertMethod.To0_1:            return Vec4Unpacker_of(c_unorm8)        elif byte_convert == FixedConvertMethod.ToMinus1_1:            return Vec4Unpacker_of(RangeConverterPrimitive(base_unpack=c_uint8, from_range=(0, 255), to_range=(-1.0, 1.0)))        elif byte_convert == FixedConvertMethod.ToByte:            return Vec4Unpacker_of(c_uint8)    raise TypeError(f"Couldn't generate vector unpacker for {vec_type}/{byte_convert}")@dataclassclass BoneWeight:    bone: int    weight: float@dataclassclass GMDVertex:    pos: Vector    bone_weights: Tuple[BoneWeight, BoneWeight, BoneWeight, BoneWeight]    normal: Optional[Vector]    tangent: Optional[Vector]    col0: Optional[Vector]    col1: Optional[Vector]    uv0: Optional[Tuple[float, float]]    uv1: Optional[Tuple[float, float]]# VertexBufferLayouts are external dependencies (shaders have a fixed layout, which we can't control) so they are frozen@dataclass(frozen=True, init=True)class GMDVertexBufferLayout:    pos_type: BaseUnpacker    weights_type: BaseUnpacker    bones_type: BaseUnpacker    normal_type: Optional[BaseUnpacker]    tangent_type: Optional[BaseUnpacker]    unk_type: Optional[BaseUnpacker]    col0_type: Optional[BaseUnpacker]    col1_type: Optional[BaseUnpacker]    uv0_type: Optional[BaseUnpacker]    uv1_type: Optional[BaseUnpacker]    @staticmethod    def make_vertex_buffer_layout(                                 pos_storage: VecStorage,                                 weights_storage: VecStorage,                                 bones_storage: VecStorage,                                 normal_storage: Optional[VecStorage],                                 tangent_storage: Optional[VecStorage],                                 unk_storage: Optional[VecStorage],                                 col0_storage: Optional[VecStorage],                                 col1_storage: Optional[VecStorage],                                 uv0_storage: Optional[VecStorage],                                 uv1_storage: Optional[VecStorage],                                 ):        return GMDVertexBufferLayout(            pos_type=make_vector_unpacker(pos_storage),            weights_type=make_vector_unpacker(weights_storage, FixedConvertMethod.To0_1),            bones_type=make_vector_unpacker(bones_storage, FixedConvertMethod.ToByte),            normal_type=make_vector_unpacker(normal_storage, FixedConvertMethod.ToMinus1_1) if normal_storage else None,            tangent_type=make_vector_unpacker(tangent_storage, FixedConvertMethod.ToMinus1_1) if tangent_storage else None,            unk_type=make_vector_unpacker(unk_storage) if unk_storage else None,            col0_type=make_vector_unpacker(col0_storage, FixedConvertMethod.To0_1) if col0_storage else None,            col1_type=make_vector_unpacker(col1_storage, FixedConvertMethod.To0_1) if col1_storage else None,            uv0_type=make_vector_unpacker(uv0_storage, FixedConvertMethod.To0_1) if uv0_storage else None,            uv1_type=make_vector_unpacker(uv1_storage, FixedConvertMethod.To0_1) if uv1_storage else None,        )    def bytes_per_vertex(self) -> int:        size = 0        size += self.pos_type.sizeof()        size += self.weights_type.sizeof()        size += self.bones_type.sizeof()        if self.normal_type:            size += self.normal_type.sizeof()        if self.tangent_type:            size += self.tangent_type.sizeof()        if self.unk_type:            size += self.unk_type.sizeof()        if self.col0_type:            size += self.col0_type.sizeof()        if self.col1_type:            size += self.col1_type.sizeof()        if self.uv0_type:            size += self.uv0_type.sizeof()        if self.uv1_type:            size += self.uv1_type.sizeof()        return size    def unpack_from(self, big_endian: bool, vertex_count: int, data: bytes, offset: int):        vertices: List[Optional[GMDVertex]] = [None] * vertex_count        # This loops over each vertex setting attribute variables (pos, weights, normal etc.) and packing them all into a vertex at the end.        # The optional attribute variables should be set to none in case they aren't unpacked        normal = None        tangent = None        unk = None        col0 = None        col1 = None        uv0 = None        uv1 = None        for i in range(vertex_count):            # unpack() returns the unpacked value and offset + size, so incrementing offset is done in one line            pos, offset = self.pos_type.unpack(big_endian, data, offset)            weights, offset = self.weights_type.unpack(big_endian, data, offset)            bones, offset = self.bones_type.unpack(big_endian, data, offset)            if self.normal_type:                normal, offset = self.normal_type.unpack(big_endian, data, offset)            if self.tangent_type:                tangent, offset = self.tangent_type.unpack(big_endian, data, offset)            if self.unk_type:                unk, offset = self.unk_type.unpack(big_endian, data, offset)            if self.col0_type:                col0, offset = self.col0_type.unpack(big_endian, data, offset)            if self.col1_type:                col1, offset = self.col1_type.unpack(big_endian, data, offset)            if self.uv0_type:                uv0, offset = self.uv0_type.unpack(big_endian, data, offset)            if self.uv1_type:                uv1, offset = self.uv1_type.unpack(big_endian, data, offset)            vertices[i] = GMDVertex(                pos = pos,                bone_weights = (                    BoneWeight(bone=bones[0], weight=weights[0]),                    BoneWeight(bone=bones[1], weight=weights[1]),                    BoneWeight(bone=bones[2], weight=weights[2]),                    BoneWeight(bone=bones[3], weight=weights[3]),                ),                normal = normal,                tangent = tangent,                col0 = col0,                col1 = col1,                uv0 = uv0,                uv1 = uv1            )        return vertices    # def check_verts(self, vertices: List[GMDVertex]):    #     for vertex in vertices:    #         if not all(vertex.pos, vertex.bone_weights):    def pack_into(self, big_endian: bool, vertices: List[GMDVertex], append_to: bytearray):        for vertex in vertices:            self.pos_type.pack(big_endian, vertex.pos, append_to=append_to)            self.weights_type.pack(big_endian, [b.weight for b in vertex.bone_weights], append_to=append_to)            self.bones_type.pack(big_endian, [b.bone for b in vertex.bone_weights], append_to=append_to)            if self.normal_type:                self.normal_type.pack(big_endian, vertex.normal, append_to=append_to)            if self.tangent_type:                self.tangent_type.pack(big_endian, vertex.tangent, append_to=append_to)            if self.unk_type:                pass #self.unk_type.pack(big_endian, vertex.u, append_to=append_to)            if self.col0_type:                self.col0_type.pack(big_endian, vertex.col0, append_to=append_to)            if self.col1_type:                self.col1_type.pack(big_endian, vertex.col1, append_to=append_to)            if self.uv0_type:                self.uv0_type.pack(big_endian, vertex.uv0, append_to=append_to)            if self.uv1_type:                self.uv1_type.pack(big_endian, vertex.uv1, append_to=append_to)# Shaders are external dependencies, so they are frozen. You can't change the name of a shader, for example.@dataclass(frozen=True)class GMDShader:    name: str    vertex_buffer_layout: GMDVertexBufferLayout